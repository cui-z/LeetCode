"""
有一个消息包含​A-Z​通过以下规则编码

'A' -> 1
'B' -> 2
...
'Z' -> 26
现在给你一个加密过后的消息，问有几种解码的方式

我们不能解码空串，因此若消息为空，你应该返回0。
消息的长度 n≤100


这其实是一道字符串类型的动态规划问题，不难发现对于字符串 s 的某个位置 i 而言， 我们只关心位 置 i 自己能否形成独立 item 和 位置 i 能够与上一位置（i-1）
能否形成 item， 二不关心 i-1 之前的位置。
有了以上分析，我们可以从前往后处理字符串 s ， 使用一个数组记录以字符串 s 的每一位作为结尾的 解码方案。即定义 f{i} 为考虑前 i 个字符的解码方案数。
对于字符串 s 的任意位置 i 而言， 其存在三种情况：
     只能由位置 i 的单独作为一个 item， 设为 a， 转移的前提是 a 的数值范围为[1, 9]， 转移逻辑为 f[i] = f[i-1]。
     只能由位置 i 的与前一位置（i-1）共同作为一个 item，设为 b， 转移的前提是 b 的数值范围为 [10， 26]， 转移逻辑为 f[i] = f[i-2]。
     位置 i 既能作为独立 item 也能与上一位置形成 item， 转移逻辑为 f[i] = f[i-1] + f[i-2]。


有个问题的关键就是0的处理
"""

def slove(strs):
    dp =[0]*(len(strs)+1)
    dp[0] = 1
    dp[1] =1

    for i in range(1,len(strs)):
        tmp1 = int(strs[i])
        tmp2 = int(strs[i-1])*10+int(strs[i])
        # if 1<= tmp1 <=9:
        #     dp[i+1] = dp[i]
        # if 10<= tmp2 <= 26:
        #     dp[i+1] += dp[i-1]
        l=(1 <= tmp1 <=9)
        r=(10 <= tmp2 <= 26)
        if l and not r:
            dp[i+1] = dp[i]
        elif not l and r:
            dp[i+1] = dp[i-1]
        elif l and r :
            dp[i+1] = dp[i]+dp[i-1]
        else:
            pass

    print(dp)
    return dp[-1]

print(slove("2263520123"))